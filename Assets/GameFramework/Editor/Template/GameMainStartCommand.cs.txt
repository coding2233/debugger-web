using HybridCLR;
using strange.extensions.command.impl;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Wanderer
{
    public class GameMainStartCommand : EventCommand
    {
        [Inject(GameContextKeys.UICanvasRoot)]
        public GameObject canvasRoot { get; set; }

        [Inject(GameContextKeys.HotUpdateRoot)]
        public GameObject hotUpdate { get; set; }

        [Inject]
        public IAssetsHelper assetHelper { get; set; }

        public override void Execute()
        {
            //加载元数据
            LoadMetadataForAOTFromResources();
            //检查更新
            assetHelper.CheckUpdate("ResoucesUpdate", (result, data, assets) =>
            {
                if (result)
                {
                    assetHelper.UpdateAssets(data, assets, null, () =>
                    {
                        LoadResourceUpdate();
                    }, (a, b) => { });
                }
                else
                {
                    LoadResourceUpdate();
                }
            });
        }

        private void LoadResourceUpdate()
        {
            
        }

        //AOT元数据
        private void LoadMetadataForAOTFromResources()
        {
            var aotDllText = Resources.Load<TextAsset>("AssembliesPostIl2CppStrip/aot.txt");
            if (aotDllText != null && !string.IsNullOrEmpty(aotDllText.text))
            {
                var aotDlls = aotDllText.text.Split('\n');
                if (aotDlls != null)
                {
                    foreach (var itemDll in aotDlls)
                    {
                        var dllData = Resources.Load<TextAsset>($"AssembliesPostIl2CppStrip/{itemDll}");
                        if (dllData != null)
                        {
                            LoadMetadataForAOTAssembly(itemDll, dllData.bytes);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// 为aot assembly加载原始metadata， 这个代码放aot或者热更新都行。
        /// 一旦加载后，如果AOT泛型函数对应native实现不存在，则自动替换为解释模式执行
        /// </summary>
        private unsafe void LoadMetadataForAOTAssembly(string dllName, byte[] dllBytes)
        {
            // 可以加载任意aot assembly的对应的dll。但要求dll必须与unity build过程中生成的裁剪后的dll一致，而不能直接使用原始dll。
            // 我们在BuildProcessor_xxx里添加了处理代码，这些裁剪后的dll在打包时自动被复制到 {项目目录}/HybridCLRData/AssembliesPostIl2CppStrip/{Target} 目录。
            // 注意，补充元数据是给AOT dll补充元数据，而不是给热更新dll补充元数据。
            // 热更新dll不缺元数据，不需要补充，如果调用LoadMetadataForAOTAssembly会返回错误
            // 加载assembly对应的dll，会自动为它hook。一旦aot泛型函数的native函数不存在，用解释器版本代码
            try
            {
                LoadImageErrorCode err = (LoadImageErrorCode)RuntimeApi.LoadMetadataForAOTAssembly(dllBytes, HomologousImageMode.SuperSet);
                Debug.Log($"LoadMetadataForAOTAssembly:{dllName}. ret:{err}");
            }
            catch (Exception e)
            {
                Debug.LogWarning(e);
            }
            //fixed (byte* ptr = dllBytes)
            //{

            //}
        }
    }
}